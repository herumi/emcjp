{"name":"emcjp","tagline":"","body":"# Effective Modern C++勉強会\r\n\r\n\r\n## 資料置き場\r\n\r\n### [本家eratta](http://www.aristeia.com/BookErrata/emc++-errata.html)\r\n\r\n### [第1回 2015/1/28](https://atnd.org/events/60511)\r\n\r\n* Item 1, 2 : [@herumi](https://twitter.com/herumi), [templateとautoの型推論](http://www.slideshare.net/herumi/template-44013078)\r\n* Item 3, 4 : [@starpoz](https://twitter.com/starpoz), [Item 3, 4](http://www.slideshare.net/starpos/effective-modern-c-1-item34)\r\n* Item 5, 6 : [@redboltz](https://twitter.com/redboltz), [Item 5, 6](http://www.slideshare.net/taka111/emcpp0506)\r\n\r\n### [第2回 2015/2/25](https://atnd.org/events/62014)\r\n\r\n* Item 7, 8 : [@Talos208](https://twitter.com/Talos208)\r\n* Item 9, 10 : [@uchan_nos](https://twitter.com/uchan_nos), [Item 9, 10](http://www.slideshare.net/uchan_nos/effective-modern-c-2pptx)\r\n* Item 11, 12 : [@keisukefukuda](https://twitter.com/keisukefukuda), [Item 11, 12](http://www.slideshare.net/KeisukeFukuda/effective-modern-c2-item1011)\r\n\r\n### 疑問やコメントなど(随時思い出したら書く)\r\n\r\n### Item 1 p.12の\r\n\r\n>These examples all show lvalue reference parameters, but\r\n>type deduction works exactly the same way for rvalue reference parameters.\r\n\r\nの意味が分からない。[テキストの間違い](misc/mail.md)\r\n\r\n### Item 2のauto a{3}がinitializer_listになるのは気持ち悪い。\r\n\r\nC++17で仕様変更された(by [@pepshiso](https://twitter.com/pepshiso/status/560384555257851904))。\r\n[New Rules for auto deduction from braced-init-list](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3922.html)\r\n\r\n```\r\n                 // C++11, C++14    C++17\r\nauto x = {1};    // 初期化リスト    初期化リスト\r\nauto x = {1, 2}; // 初期化リスト    初期化リスト\r\nauto x{1};       // 初期化リスト    int\r\nauto x{1, 2};    // 初期化リスト    error\r\n```\r\n\r\n### Item 3のdecltype(x)とdecltype((x))で意味が変わる例\r\n\r\n```\r\n// C++14 only\r\ndecltype(auto) f2()\r\n{\r\n    static int x = 0;\r\n    return (x); // ここをreturn xにするとコンパイルエラーになる。\r\n}\r\n\r\nint main()\r\n{\r\n    printf(\"f2()=%d\\n\", f2());\r\n    f2() = 3;\r\n    printf(\"f2()=%d\\n\", f2());\r\n}\r\n```\r\n\r\n### Item 6のvector<bool>のoperatorをautoで受けると駄目な話。\r\n\r\n[item6-1.cpp](https://github.com/herumi/emcjp/blob/master/src/item6-1.cpp)\r\nVecがintではなくRefを返す。\r\nintで受けるとRef()からintに変換されてから一時オブジェクトのVecとRefが消滅する。\r\n\r\nautoで受けるとRef()のままになり、Refの寿命はあるけどそれが参照しているVecは先に消滅するのでそのあとintに変換するとアウト。\r\n```\r\nuse int\r\nVec cstr\r\nRef cstr\r\nread x\r\nRef dstr\r\nVec dstr\r\ntype=int a=5\r\nuse auto\r\nVec cstr\r\nRef cstr\r\nVec dstr\r\nread x\r\ntype=struct Ref a=5\r\nRef dstr\r\n```\r\n\r\n### std::vector<T>::size_typeはsize_tで受けてよいのか?\r\n\r\n問題になるとは思えないがどこかで保証してる?\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}